using System;
using System.Linq;

// класс отвечающий за мяч
class Ball
{
    // сам мячик
    public Pixel ball;
    // стартовые координаты куда ему двигаться
    public double ballX = 0;
    public double ballY = 0;
    // старые стартовые координаты чтобы мяч при спавне не летел в одно и тоже место
    public double OldBallX = 0;
    public double OldBallY = 0;
    // фактор увеличения координаты при отбивании мяча от игрока
    // чтобы сделать игру более динамичной я сделал так чтобы смотря при отбивании какой частью ракетки
    // мяч летит по соответствующей диагонали а не просто по пряиой
    public double OldBallfactor = 0;
    // скорость мяча
    public double speed = 1.0;
    // множитель для фактора
    public double factor = 0.15;
    
    // создание мяча и отрисовка
    // стартовая координата X
    // стартовая координата Y
    // Пиксель которым будет выглядеть мячик
    // цвет мяча
    // версия игры ( 1 - соло, 2 - дуэль)
    public Ball(int X, int Y, char Pixel, ConsoleColor Color, int gameversion)
    {
        // если дуэль
        if (gameversion == 2)
        {
            // создаем мячик
            ball = new Pixel(X, Y, Pixel, Color);
            // задаем стартовые рандомные координаты движения от -1 до 1 из чисел с плавающей точкой
            Random random = new Random();
            // создаем координаты и делаем так чтобы мяч никогда при спавне два раза подряд не летел в одну сторону
            do
            {
                // присваививаем число строго либо -1 либо 1
                ballX = random.Next(0, 2) * 2 - 1;
                ballY = random.Next(-1, 2);
            }
            while (ballX != 0 && OldBallX == ballX && OldBallY == ballY);
            // заполняем старые координаты чтобы при последующем создании не летел туда же
            OldBallX = ballX;
            OldBallY = ballY;
        }
        else
        {
            // создаем мячик
            ball = new Pixel(X, Y, Pixel, Color);
            // задаем стартовые рандомные координаты движения от -1 до 1 из чисел с плавающей точкой
            Random random = new Random();
            // создаем координаты и делаем так чтобы мяч никогда при спавне два раза подряд не летел в одну сторону
            do
            {
                ballX = random.Next(-1, 2);
                ballY = -1;
            }
            while (OldBallX == ballX && OldBallY == ballY);
            // заполняем старые координаты чтобы при последующем создании не летел туда же
            OldBallX = ballX;
            OldBallY = ballY;
        }
    }
    // функция движения
    public void Move(Player player1, Player player2 = null)
    {
        // для дуэли движение
        if (player2 != null)
        {
            // x - влево
            // y = вниз
            // если мячик доходит до верха или низа
            if (ball.y <= 2 || ball.y >= tennis.Program.heightsize * tennis.Program.multipliersize - 3)
            {
                // меняем направление мячика
                ballY = ballY > 0 ? -1 : 1;
                // увеличиваем скорость мяча
                speed += 0.1;
                // ставим фактор равный 0 чтобы он не менял значение координаты 
                OldBallfactor = 0;
                // отрисовывем барьер ведь на большой скорости мячик может вылететь из него или в нем отрисоваться и чтобы не было видно 
                // пустоты вместо барьера мы его и рисуем
                tennis.Program.barrier();
            }
            // если доходит до игроков
            if (player1.racket.Any(ch => ch.y == ball.y && ch.x >= ball.x-1) || player2.racket.Any(ch => ch.y == ball.y && ch.x <= ball.x+1))
            {
                // создаем два массива чтобы получить тот фрагмент(чар) которым отбили мячик
                // это нужно для большей динамичности игры чтобы мяч летел не только по прямым 
                Pixel[] playerchar1 = player1.racket.Where(ch => ch.y == ball.y && ch.x >= ball.x - 1).ToArray();
                Pixel[] playerchar2 = player2.racket.Where(ch => ch.y == ball.y && ch.x <= ball.x + 1).ToArray();
                // если отбил игрок слева
                if (playerchar1.Length > playerchar2.Length)
                {
                    // берем индекс фрагмента из массива
                    int index = Array.IndexOf(player1.racket, playerchar1.First());
                    // если фрагмент в нижней части, то и полетит вниз
                    if (index > 4)
                    {
                        // тут мы присваем увеличителю Y значение равное
                        // фактор = 0.1 * (индекс фрагемента -3)
                        // -3 нужен чтобы высчитывать номер чара относительно центра
                        // к примеру самый верхний и самый нижний чар так будут иметь одинаковый индекс
                        ballY = factor * (index - 3);
                    }
                    else
                    {
                        // тут в целом все тоже самое только меняем направление через минус 
                        ballY = -factor * (4 / ++index);
                    }
                }
                // если отбил игрок справа
                else
                {
                    // берем индекс фрагмента из массива
                    int index = Array.IndexOf(player2.racket, playerchar2.First());
                    // если фрагмент в нижней части, то и полетит вниз
                    if (index > 4)
                    {
                        // тут мы присваем увеличителю Y значение равное
                        // фактор = 0.1 * (индекс фрагемента -3)
                        // -3 нужен чтобы высчитывать номер чара относительно центра
                        // к примеру самый верхний и самый нижний чар так будут иметь одинаковый индекс
                        ballY = factor * (index - 3);
                    }
                    else
                    {
                        // тут в целом все тоже самое только меняем направление через минус 
                        ballY = -factor * (4 / ++index);
                    }
                }
                // меняем значение старому фактору чтобы оно добавляло для дробной координаты значение 
                OldBallfactor = ballY;
                // меняем направление
                ballX *= -1;
                // увеличиваем скорость
                speed += 0.01;
            }
            // убираем шарик
            ball.Clear();
            // меняем координаты
            ball.x += (int)(speed * Math.Round(ballX));
            ball.y += (int)(speed * Math.Round(ballY));
            // блок если координата дробная (тоесть отбита от игрока)
            // тут к координате прибавляется дробное значение чтобы оно раз в пару кадров было равным целому числу чтобы сдвинуться по коорднате
            // после чего возвращает свое первоначальное значение чтобы сохранить ту диагональ по которой она должна лететь
            if (OldBallfactor != 0)
            {
                ballY += ballY;
                if (ballY > 1)
                {
                    ballY = OldBallfactor;
                }
                else if (ballY < -1)
                {
                    ballY = -Math.Abs(OldBallfactor);
                }
            }
            // рисуем шарик
            ball.Draw();
        }
        else
        {
            // если мячик доходит до верха
            if (ball.y <= 0)
            {
                // меняем направление мячика
                ballY *= -1;
                speed += 0.01;
            }
            // если мяч доходит до сторон боковых
            if (ball.x <= 0 || ball.x >= tennis.Program.widthsize * tennis.Program.multipliersize - 1)
            {
                // меняем направление мяча
                ballX = ballX > 0 ? -1 : 1;
                // ставим фактор равный 0 чтобы он не менял значение координаты 
                OldBallfactor = 0;
                // увеличиваем скорость
                speed += 0.01;
            }
            if (player1.racket.Any(ch => ch.x == ball.x && ball.y == ch.y - 1))
            {
                // создаем два массива чтобы получить тот фрагмент(чар) которым отбили мячик
                // это нужно для большей динамичности игры чтобы мяч летел не только по прямым 
                Pixel playerchar = player1.racket.Where(ch => ch.x == ball.x && ball.y == ch.y - 1).First();
                // берем индекс фрагмента из массива
                int index = Array.IndexOf(player1.racket, playerchar);
                // если фрагмент в нижней части, то и полетит вниз
                if (index > 4)
                {
                    // тут мы присваем увеличителю Y значение равное
                    // фактор = 0.1 * (индекс фрагемента -3)
                    // -3 нужен чтобы высчитывать номер чара относительно центра
                    // к примеру самый верхний и самый нижний чар так будут иметь одинаковый индекс
                    ballX = factor * (index - 3);
                }
                else
                {
                    // тут в целом все тоже самое только меняем направление через минус 
                    ballX = -factor * (4 / ++index);
                }
                // меняем значение старому фактору чтобы оно добавляло для дробной координаты значение 
                OldBallfactor = ballX;
                // меняем направление
                ballY *= -1;
                // увеличиваем скорость
                speed += 0.01;
                // увеличиваем счет игрока так как в соло режиме счет это сколько раз игрок отбил мяч
                tennis.Program.playeronescore++;
                // обновляем счет
                tennis.Program.SoloScore();
            }
            // убираем шарик
            ball.Clear();
            // меняем координаты
            ball.x += (int)(speed * Math.Round(ballX));
            ball.y += (int)(speed * Math.Round(ballY));
            // блок если координата дробная (тоесть отбита от игрока)
            // тут к координате прибавляется дробное значение чтобы оно раз в пару кадров было равным целому числу чтобы сдвинуться по коорднате
            // после чего возвращает свое первоначальное значение чтобы сохранить ту диагональ по которой она должна лететь
            if (OldBallfactor != 0)
            {
                ballX += ballX;
                if (ballX > 1)
                {
                    ballX = OldBallfactor;
                }
                else if (ballX < -1)
                {
                    ballX = -Math.Abs(OldBallfactor);
                }
            }
            // рисуем шарик
            ball.Draw();
        }
    }
}

